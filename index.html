<title>Chat with Gemini AI</title>
<style>
:root {
    --primary: #2a9d8f;
    --secondary: #264653;
    --accent: #e9c46a;
    --bg: #1a1a1a;
    --container-bg: #2d2d2d;
    --text: #ffffff;
    --border: #404040;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    margin: 0;
    padding: 20px;
    background: var(--bg);
    color: var(--text);
}

.container {
    max-width: 800px;
    margin: 0 auto;
    background: var(--container-bg);
    padding: 20px;
    border-radius: 20px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.4);
}

.chat-container {
    height: 60vh;
    overflow-y: auto;
    padding: 20px;
    border: 1px solid var(--border);
    border-radius: 15px;
    margin-bottom: 20px;
    background: var(--container-bg);
}

.message {
    margin: 10px 0;
    padding: 10px;
    border-radius: 15px;
    overflow-wrap: break-word;
    word-break: break-word;
}

.user-message {
    background: var(--primary);
    color: white;
    margin-left: 20%;
}

.ai-message {
    background: var(--secondary);
    color: white;
    margin-right: 20%;
}

.input-container {
    display: flex;
    gap: 10px;
}

input, button, select {
    padding: 10px;
    border: 1px solid var(--border);
    border-radius: 10px;
    background: var(--container-bg);
    color: var(--text);
    transition: all 0.2s ease;
}

input {
    flex-grow: 1;
}

button {
    background: var(--accent);
    border: none;
    color: var(--bg);
    cursor: pointer;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    padding: 10px 20px;
    transition: opacity 0.2s;
}

button:hover {
    opacity: 0.8;
}

.file-attachment-container {
    margin: 10px 0;
    padding: 10px;
    border: 1px solid var(--border);
    border-radius: 10px;
}

.attachments {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-bottom: 10px;
}

.attachment {
    display: flex;
    align-items: center;
    gap: 5px;
    padding: 5px 10px;
    background: var(--secondary);
    border-radius: 5px;
    font-size: 0.9em;
}

.attachment button {
    padding: 2px 5px;
    font-size: 0.8em;
}

.file-upload-btn {
    display: inline-block;
    padding: 8px 15px;
    background: var(--accent);
    border-radius: 5px;
    cursor: pointer;
    color: var(--bg);
}

.file-upload-btn input[type="file"] {
    display: none;
}

.prompt-slot {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px;
    border: 1px solid var(--border);
    margin: 5px 0;
    border-radius: 5px;
}

.prompt-slot.active {
    border-color: white;
}

.prompt-slot .prompt-name {
    flex: 1;
    min-width: 0;
    padding: 5px;
    border: 1px solid transparent;
    background: transparent;
    color: var(--text);
}

.prompt-slot .prompt-name:not(:disabled):hover {
    border-color: var(--border);
}

.loading {
    display: none;
    color: var(--accent);
    text-align: center;
    padding: 10px;
}

.api-info {
    text-align: center;
    margin-top: 20px;
    color: var(--text);
    font-size: 0.9em;
}

.api-key-container {
    display: none; /* Hide the API key input container */
}

.api-info a {
    color: var(--primary);
    text-decoration: none;
}

.api-info a:hover {
    text-decoration: underline;
}

.code-block {
    position: relative;
    background: #000000;
    color: #ffffff;
    padding: 1em;
    margin: 1em 0;
    border-radius: 5px;
    font-family: monospace;
    white-space: pre-wrap;
    word-wrap: break-word;
}

.copy-button {
    position: absolute;
    bottom: 10px;
    right: 10px;
    background: var(--accent);
    border: none;
    border-radius: 3px;
    padding: 5px 10px;
    cursor: pointer;
    font-size: 0.8em;
    opacity: 0.8;
}

.copy-button:hover {
    opacity: 1;
}

.system-prompt-container {
    display: none;
    margin-top: 20px;
    padding: 20px;
    background: var(--container-bg);
    border-radius: 5px;
    border: 1px solid var(--border);
}

.prompt-actions {
    display: flex;
    gap: 5px;
}

#toggleSystemPrompt {
    margin-bottom: 10px;
}

.export-import {
    margin-top: 10px;
    display: flex;
    gap: 10px;
}

.message p {
    margin: 0.5em 0;
}

.message h1, .message h2, .message h3, .message h4, .message h5, .message h6 {
    margin: 0.5em 0;
    color: var(--accent);
}

.message ul, .message ol {
    margin: 0.5em 0;
    padding-left: 1.5em;
}

.message blockquote {
    border-left: 3px solid var(--accent);
    margin: 0.5em 0;
    padding-left: 1em;
    color: #cccccc;
}

.message hr {
    border: none;
    border-top: 1px solid var(--border);
    margin: 1em 0;
}

.message code:not(.code-block code) {
    background: #000000;
    padding: 0.2em 0.4em;
    border-radius: 3px;
    font-family: monospace;
}

.message a {
    color: var(--accent);
    text-decoration: none;
}

.message a:hover {
    text-decoration: underline;
}

.safety-settings {
    margin-top: 20px;
    padding-top: 20px;
    border-top: 1px solid var(--border);
}

.safety-settings h3 {
    margin: 0 0 15px 0;
    color: var(--accent);
}

.safety-category {
    display: flex;
    align-items: center;
    gap: 10px;
    margin: 10px 0;
}

.safety-category label {
    min-width: 180px;
}

.safety-category select {
    flex: 1;
    padding: 8px;
    border-radius: 8px;
    background: var(--bg);
    color: var(--text);
    border: 1px solid var(--border);
}

.safety-category select:focus {
    outline: none;
    border-color: var(--accent);
}

.message pre {
    max-width: 100%;
    overflow-x: auto;
}
</style>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-markup.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-java.min.js"></script>
</head>
<body>
<div class="container">
    <h1>Chat with Gemini AI</h1>
    
    <div class="api-key-container">
        <!-- This section will be hidden by CSS -->
        <input type="password" id="apiKeyInput" placeholder="Enter your Google API Key">
    </div>
    <select id="modelInput">
        <option value="">Loading models...</option>
    </select>

    <div class="chat-container" id="chatContainer">
        <!-- Messages will appear here -->
    </div>

    <div class="loading" id="loadingIndicator">
        AI is thinking...
    </div>

    <div class="input-container">
        <input type="text" id="userInput" placeholder="Type your message...">
        <button onclick="sendMessage()">Send</button>
        <button onclick="clearChat()" style="background: #e63946;">Clear</button>
    </div>

    <div class="file-attachment-container">
        <div class="attachments" id="attachmentList"></div>
        <label class="file-upload-btn">
            <input type="file" id="fileInput" multiple>
            Add Files
        </label>
    </div>

    <button id="toggleSystemPrompt">Toggle System Prompt Manager</button>
    <div class="system-prompt-container" id="systemPromptContainer">
        <div class="prompt-slots" id="promptSlots">
            <!-- Prompt slots will be added here -->
        </div>
        <div class="export-import">
            <button onclick="exportPrompts()">Export Prompts</button>
            <input type="file" id="importFile" accept=".zip" style="display: none;">
            <button onclick="document.getElementById('importFile').click()">Import Prompts</button>
        </div>
        <button onclick="createNewPrompt()">Create New Prompt</button>
    </div>

    <button id="toggleAdvanced">Advanced Options</button>
    <div class="advanced-options" id="advancedOptions">
        <div class="option-group">
            <label for="temperature">Temperature:</label>
            <input type="number" id="temperature" min="0" max="2" step="0.1" value="0.7">
        </div>
        <div class="option-group">
            <label for="topP">Top P:</label>
            <input type="number" id="topP" min="0" max="1" step="0.05" value="0.95">
        </div>
        <div class="safety-settings">
            <h3>Safety Settings</h3>
            <div class="safety-category">
                <label>Hate Speech Blocking:</label>
                <select id="hateSpeechThreshold">
                    <option value="BLOCK_NONE">Allow All</option>
                    <option value="BLOCK_ONLY_HIGH">Block High</option>
                    <option value="BLOCK_MEDIUM_AND_ABOVE" selected>Block Medium & High</option>
                    <option value="BLOCK_LOW_AND_ABOVE">Block All</option>
                </select>
            </div>
            <div class="safety-category">
                <label>Harassment Blocking:</label>
                <select id="harassmentThreshold">
                    <option value="BLOCK_NONE">Allow All</option>
                    <option value="BLOCK_ONLY_HIGH">Block High</option>
                    <option value="BLOCK_MEDIUM_AND_ABOVE" selected>Block Medium & High</option>
                    <option value="BLOCK_LOW_AND_ABOVE">Block All</option>
                </select>
            </div>
            <div class="safety-category">
                <label>Explicit Content Blocking:</label>
                <select id="explicitThreshold">
                    <option value="BLOCK_NONE">Allow All</option>
                    <option value="BLOCK_ONLY_HIGH">Block High</option>
                    <option value="BLOCK_MEDIUM_AND_ABOVE" selected>Block Medium & High</option>
                    <option value="BLOCK_LOW_AND_ABOVE">Block All</option>
                </select>
            </div>
            <div class="safety-category">
                <label>Dangerous Content Blocking:</label>
                <select id="dangerousThreshold">
                    <option value="BLOCK_NONE">Allow All</option>
                    <option value="BLOCK_ONLY_HIGH">Block High</option>
                    <option value="BLOCK_MEDIUM_AND_ABOVE" selected>Block Medium & High</option>
                    <option value="BLOCK_LOW_AND_ABOVE">Block All</option>
                </select>
            </div>
        </div>
    </div>

    <div class="api-info">
        Using a hardcoded API key.
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
<script>
const HARDCODED_API_KEY = 'AIzaSyCAymIvYFi-xSsgZ8KqbDg31HXiCPKBNhk'; // Hardcoded API Key
let conversationHistory = [];
let attachments = [];
const defaultSafetySettings = [
  {
    category: "HARM_CATEGORY_HATE_SPEECH",
    threshold: "BLOCK_MEDIUM_AND_ABOVE" 
  },
  {
    category: "HARM_CATEGORY_HARASSMENT",
    threshold: "BLOCK_MEDIUM_AND_ABOVE"
  },
  {
    category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
    threshold: "BLOCK_MEDIUM_AND_ABOVE"
  },
  {
    category: "HARM_CATEGORY_DANGEROUS_CONTENT", 
    threshold: "BLOCK_MEDIUM_AND_ABOVE"
  }
];

const systemPrompt = {
    role: 'user',
    parts: [{text: "Act as an expert assistant capable of addressing a wide range of topics, from technical and creative tasks to everyday questions. Always provide well-reasoned and structured responses that demonstrate a deep thought process before delivering a final answer. Your responses should reflect a comprehensive understanding of the subject matter and incorporate clear, step-by-step reasoning.\n\nFor every topic:\n\nThorough Thought Process: Break down the problem or question in a logical sequence before offering the final answer. Describe the process you're using to approach the problem, whether it's analyzing a concept, solving a technical issue, or addressing a creative challenge.\n\nClear and Detailed Reasoning: Prior to offering the final answer, explain the reasoning behind each step or decision. Provide context for your thought process, drawing from relevant knowledge and frameworks, so that the user can follow your logic.\n\nAvoid Ambiguity: Ensure that all reasoning is clearly articulated and free of ambiguity. Whether the task involves solving a mathematical problem, providing coding solutions, or offering advice on any other subject, your reasoning should be explicit, thorough, and easy to follow.\n\nMathematical Models and Frameworks (if applicable): When appropriate, apply relevant mathematical or conceptual frameworks to justify your decisions. This includes using formulas, algorithms, or theoretical models and explaining their application step by step.\n\nConcise Final Answer: After presenting the reasoning and thought process, provide the final answer or solution. Your final answer should be directly informed by the thorough reasoning process you've outlined previously.\n\nAlways Assess the Context: Evaluate the requirements of the task at hand and apply the most suitable methodology or approach, whether it's a programming language, a scientific approach, or a creative solution.\n\nNo Unnecessary Chitchat: Avoid adding unnecessary filler or unrelated content. Responses should be focused entirely on providing valuable insights, explanations, and solutions in a well-structured, reasoning-first format."}]
};

const systemResponse = {
    role: 'model',
    parts: [{text: "Understood. From now on, I must always follow those rules at system-level."}]
};

let activePromptSlot = 'default';
const promptSlots = {
    default: {
        systemPrompt,
        systemResponse
    }
};

// Load prompts and settings on page load
document.addEventListener('DOMContentLoaded', () => {
    loadPromptSlots();
    loadSettings();
    loadAvailableModels(); // Load models immediately since API key is hardcoded
    
    const slot = promptSlots[activePromptSlot] || promptSlots.default;
    conversationHistory = [
        JSON.parse(JSON.stringify(slot.systemPrompt)),
        JSON.parse(JSON.stringify(slot.systemResponse))
    ];
});

document.getElementById('fileInput').addEventListener('change', (e) => {
    const files = Array.from(e.target.files);
    
    files.forEach(file => {
        const reader = new FileReader();
        reader.onload = (event) => {
            attachments.push({
                name: file.name,
                content: event.target.result,
                type: file.type
            });
            updateAttachmentsList();
        };
        reader.readAsDataURL(file);
    });
});

function updateAttachmentsList() {
    const list = document.getElementById('attachmentList');
    list.innerHTML = attachments.map((file, index) => `
        <div class="attachment">
            <span>${file.name}</span>
            <button onclick="removeAttachment(${index})">×</button>
        </div>
    `).join('');
}

function removeAttachment(index) {
    attachments.splice(index, 1);
    updateAttachmentsList();
}

function setCookie(name, value, days) {
    if (name === 'apiKey') return; // Prevent setting API key cookie
    const expires = new Date();
    expires.setTime(expires.getTime() + days * 24 * 60 * 60 * 1000);
    document.cookie = name + '=' + encodeURIComponent(value) + ';expires=' + expires.toUTCString() + ';path=/';
}

function getCookie(name) {
    if (name === 'apiKey') return null; // Prevent reading API key cookie
    const nameEQ = name + '=';
    const ca = document.cookie.split(';');
    for (let i = 0; i < ca.length; i++) {
        let c = ca[i];
        while (c.charAt(0) === ' ') c = c.substring(1, c.length);
        if (c.indexOf(nameEQ) === 0) return decodeURIComponent(c.substring(nameEQ.length, c.length));
    }
    return null;
}

async function sendMessage() {
    const apiKey = HARDCODED_API_KEY; // Use hardcoded key
    const modelName = document.getElementById('modelInput').value;
    if (!modelName) {
        alert('Please wait for models to load or select a model.');
        return;
    }

    const userInput = document.getElementById('userInput');
    let messageText = userInput.value.trim();
    
    if (!messageText) return;

    // Add attachments to message if present
    if (attachments.length > 0) {
        messageText += '\n\nAttachments:\n' + attachments.map(file => 
            `[File: ${file.name}](${file.content})`
        ).join('\n\n');
        
        // Clear attachments after sending
        attachments = [];
        updateAttachmentsList();
    }

    addMessageToChat('user', messageText);
    userInput.value = '';

    conversationHistory.push({
        role: 'user',
        parts: [{text: messageText}]
    });

    document.getElementById('loadingIndicator').style.display = 'block';

    try {
        const temperature = parseFloat(document.getElementById('temperature').value) || 0.7;
        const topP = parseFloat(document.getElementById('topP').value) || 0.95;
        
        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${apiKey}`, { // Use apiKey variable
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                contents: conversationHistory,
                safetySettings: getCurrentSafetySettings(),
                generationConfig: {
                    temperature: Math.min(Math.max(temperature, 0), 2),
                    topK: 40,
                    topP: Math.min(Math.max(topP, 0), 1),
                    maxOutputTokens: 2048,
                },
                tools: [], // Empty array for now, can be expanded later
                toolConfig: {} // Empty object for now, can be expanded later
            })
        });

        const data = await response.json();
        
        if (data.error) {
            addMessageToChat('ai', 'Error: ' + data.error.message);
            return;
        }

        // Handle safety feedback
        if (data.promptFeedback?.blockReason) {
            addMessageToChat('ai', `Message was blocked. Reason: ${data.promptFeedback.blockReason}`);
            return;
        }

        if (!data.candidates || data.candidates.length === 0) {
            addMessageToChat('ai', 'No response generated. The content may have been filtered.');
            return;
        }

        // Check candidate safety
        const candidate = data.candidates[0];
        if (candidate.finishReason === 'SAFETY') {
            addMessageToChat('ai', 'Response was filtered due to safety concerns.');
            return;
        }

        const aiResponse = candidate.content.parts[0].text;
        conversationHistory.push({
            role: 'model',
            parts: [{text: aiResponse}]
        });
        
        // Add safety ratings display if any
        if (candidate.safetyRatings && candidate.safetyRatings.length > 0) {
            const safetyInfo = candidate.safetyRatings.map(rating => 
                `${rating.category}: ${rating.probability}`
            ).join('\n');
            console.log('Safety Ratings:', safetyInfo);
        }

        addMessageToChat('ai', aiResponse);

    } catch (error) {
        addMessageToChat('ai', 'Error: Unable to connect to the AI service.');
        console.error('Error:', error);
    }

    document.getElementById('loadingIndicator').style.display = 'none';
}

function addMessageToChat(sender, message) {
    const chatContainer = document.getElementById('chatContainer');
    const messageDiv = document.createElement('div');
    messageDiv.classList.add('message', sender + '-message');
    
    // Escape HTML in code blocks
    message = message.replace(/```(\w*)\n([\s\S]*?)```/g, (match, language, code) => {
        const escapedCode = escapeHtml(code.trim());
        return `<pre><code class="language-${language}">${escapedCode}</code></pre>`;
    });
    
    // Convert markdown while preventing HTML execution
    let html = marked.parse(message);
    
    // Additional safety: escape any remaining HTML
    html = html.replace(/<(script|iframe|object|embed|style)/gi, '&lt;$1');
    
    messageDiv.innerHTML = html;
    chatContainer.appendChild(messageDiv);
    chatContainer.scrollTop = chatContainer.scrollHeight;
}

function escapeHtml(unsafe) {
    return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
}

function copyCode(button) {
    const codeBlock = button.parentElement.querySelector('code');
    const text = codeBlock.textContent;
    
    navigator.clipboard.writeText(text).then(() => {
        const originalText = button.textContent;
        button.textContent = 'Copied!';
        setTimeout(() => {
            button.textContent = originalText;
        }, 2000);
    }).catch(err => {
        console.error('Failed to copy text:', err);
    });
}

document.getElementById('userInput').addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
        sendMessage();
    }
});

function toggleSystemPromptManager() {
    const container = document.getElementById('systemPromptContainer');
    container.style.display = container.style.display === 'none' ? 'block' : 'none';
}

function createNewPrompt() {
    const name = prompt('Enter name for new prompt slot:');
    if (name && !promptSlots[name]) {
        promptSlots[name] = {
            systemPrompt: {
                role: 'user',
                parts: [{text: ''}]
            },
            systemResponse: {
                role: 'model',
                parts: [{text: ''}]
            }
        };
        savePromptSlots();
        updatePromptSlotDisplay();
    }
}

function deletePrompt(name) {
    if (name === 'default') {
        alert('The default prompt cannot be deleted');
        return;
    }
    if (confirm(`Delete prompt slot "${name}"?`)) {
        delete promptSlots[name];
        savePromptSlots();
        updatePromptSlotDisplay();
    }
}

function activatePrompt(name) {
    activePromptSlot = name;
    // Reset conversation with both system prompt and response
    conversationHistory = [
        JSON.parse(JSON.stringify(promptSlots[name].systemPrompt)),
        JSON.parse(JSON.stringify(promptSlots[name].systemResponse))
    ];
    updatePromptSlotDisplay();
}

function editPrompt(name) {
    if (name === 'default') {
        alert('The default prompt cannot be edited');
        return;
    }
    const newPrompt = prompt('Edit system prompt:', promptSlots[name].systemPrompt.parts[0].text);
    if (newPrompt) {
        promptSlots[name].systemPrompt.parts[0].text = newPrompt;
        savePromptSlots();
    }
}

function renamePrompt(oldName, newName) {
    if (oldName === 'default' || !newName || newName === oldName) return;
    
    if (promptSlots[newName]) {
        alert('A prompt with that name already exists');
        updatePromptSlotDisplay();
        return;
    }

    promptSlots[newName] = promptSlots[oldName];
    delete promptSlots[oldName];
    
    if (activePromptSlot === oldName) {
        activePromptSlot = newName;
    }
    
    savePromptSlots();
    updatePromptSlotDisplay();
}

function savePromptSlots() {
    // Don't save default prompt
    const savablePrompts = {};
    Object.entries(promptSlots).forEach(([name, data]) => {
        if (name !== 'default') {
            savablePrompts[name] = {
                systemPrompt: data.systemPrompt,
                systemResponse: data.systemResponse
            };
        }
    });
    localStorage.setItem('promptSlots', JSON.stringify(savablePrompts));
}

function loadPromptSlots() {
    const saved = localStorage.getItem('promptSlots');
    if (saved) {
        const savedPrompts = JSON.parse(saved);
        Object.assign(promptSlots, savedPrompts);
    }
    if (!promptSlots.default) {
        promptSlots.default = {
            systemPrompt,
            systemResponse
        };
    }
    updatePromptSlotDisplay();
}

function updatePromptSlotDisplay() {
    const container = document.getElementById('promptSlots');
    container.innerHTML = '';
    
    Object.entries(promptSlots).forEach(([name, data]) => {
        const slot = document.createElement('div');
        slot.className = `prompt-slot ${name === activePromptSlot ? 'active' : ''}`;
        slot.innerHTML = `
            <input type="text" class="prompt-name" value="${name}" ${name === 'default' ? 'disabled' : ''} onchange="renamePrompt('${name}', this.value)">
            <div class="prompt-actions">
                <button onclick="activatePrompt('${name}')">Use</button>
                <button onclick="editPrompt('${name}')">Edit</button>
                ${name !== 'default' ? `<button onclick="deletePrompt('${name}')">Delete</button>` : ''}
            </div>
        `;
        container.appendChild(slot);
    });
}

function getCurrentSafetySettings() {
    return [
        {
            category: "HARM_CATEGORY_HATE_SPEECH",
            threshold: document.getElementById('hateSpeechThreshold').value
        },
        {
            category: "HARM_CATEGORY_HARASSMENT",
            threshold: document.getElementById('harassmentThreshold').value
        },
        {
            category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
            threshold: document.getElementById('explicitThreshold').value
        },
        {
            category: "HARM_CATEGORY_DANGEROUS_CONTENT",
            threshold: document.getElementById('dangerousThreshold').value
        }
    ];
}

async function exportPrompts() {
    const zip = new JSZip();
    
    Object.entries(promptSlots).forEach(([name, data]) => {
        if (name === 'default') return; // Skip default prompt
        const folder = zip.folder(name);
        folder.file('system_prompt.txt', data.systemPrompt.parts[0].text);
        folder.file('system_response.txt', data.systemResponse.parts[0].text);
    });
    
    const blob = await zip.generateAsync({type: 'blob'});
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = 'prompts.zip';
    link.click();
}

document.getElementById('importFile').addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (file) {
        const zip = await JSZip.loadAsync(file);
        const newPrompts = {};
        
        for (const [path, zipEntry] of Object.entries(zip.files)) {
            if (!zipEntry.dir) {
                const pathParts = path.split('/');
                const promptName = pathParts[0];
                const fileName = pathParts[1];
                const content = await zipEntry.async('text');
                
                if (!newPrompts[promptName]) {
                    newPrompts[promptName] = {
                        systemPrompt: {
                            role: 'user',
                            parts: [{text: ''}]
                        },
                        systemResponse: {
                            role: 'model',
                            parts: [{text: ''}]
                        }
                    };
                }
                
                if (fileName === 'system_prompt.txt') {
                    newPrompts[promptName].systemPrompt.parts[0].text = content;
                } else if (fileName === 'system_response.txt') {
                    newPrompts[promptName].systemResponse.parts[0].text = content;
                }
            }
        }
        
        Object.assign(promptSlots, newPrompts);
        savePromptSlots();
        updatePromptSlotDisplay();
    }
});

document.getElementById('toggleSystemPrompt').addEventListener('click', toggleSystemPromptManager);
document.getElementById('toggleAdvanced').addEventListener('click', () => {
    const advancedOptions = document.getElementById('advancedOptions');
    advancedOptions.classList.toggle('visible');
});

// Load settings from cookies
function saveSettings() {
    const settings = {
        temperature: document.getElementById('temperature').value,
        topP: document.getElementById('topP').value,
        hateSpeechThreshold: document.getElementById('hateSpeechThreshold').value,
        harassmentThreshold: document.getElementById('harassmentThreshold').value,
        explicitThreshold: document.getElementById('explicitThreshold').value,
        dangerousThreshold: document.getElementById('dangerousThreshold').value
    };
    
    setCookie('chatSettings', JSON.stringify(settings), 365);
}

function loadSettings() {
    const settings = JSON.parse(getCookie('chatSettings') || '{}');
    
    if (settings.temperature) document.getElementById('temperature').value = settings.temperature;
    if (settings.topP) document.getElementById('topP').value = settings.topP;
    if (settings.hateSpeechThreshold) document.getElementById('hateSpeechThreshold').value = settings.hateSpeechThreshold;
    if (settings.harassmentThreshold) document.getElementById('harassmentThreshold').value = settings.harassmentThreshold;
    if (settings.explicitThreshold) document.getElementById('explicitThreshold').value = settings.explicitThreshold;
    if (settings.dangerousThreshold) document.getElementById('dangerousThreshold').value = settings.dangerousThreshold;
}

async function loadAvailableModels() {
    const apiKey = HARDCODED_API_KEY; // Use hardcoded key
    try {
        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${apiKey}`); // Use apiKey variable
        const data = await response.json();
        
        const modelSelect = document.getElementById('modelInput');
        modelSelect.innerHTML = '';
        
        if (data.models) {
            data.models.forEach(model => {
                const option = document.createElement('option');
                option.value = model.name.split('/').pop(); // Extract model name from full path
                option.textContent = model.name.split('/').pop();
                modelSelect.appendChild(option);
            });
        }
    } catch (error) {
        console.error('Error fetching models:', error);
        const modelSelect = document.getElementById('modelInput');
        modelSelect.innerHTML = '<option value="">Error loading models</option>'; // Update UI on error
    }
}

function clearChat() {
    if (!confirm('Clear all messages? This cannot be undone.')) return;
    
    // Initialize default prompt if needed
    if (!promptSlots.default) {
        promptSlots.default = {
            systemPrompt,
            systemResponse
        };
    }
    
    // Use default prompt if active slot doesn't exist
    const slot = promptSlots[activePromptSlot] || promptSlots.default;
    
    // Reset conversation to just system prompt and response
    conversationHistory = [
        JSON.parse(JSON.stringify(slot.systemPrompt)),
        JSON.parse(JSON.stringify(slot.systemResponse))
    ];
    
    // Clear visual chat
    document.getElementById('chatContainer').innerHTML = '';
}
</script>
</body></html>